/**
 * Skargrid v1.0.0
 * Build completo - Arquivo unico para uso em producao
 */
(function(global, factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory();
  } else {
    global.Skargrid = factory();
  }
}(typeof self !== 'undefined' ? self : this, function() {

/**
 * Skargrid Core - Implementação de renderização e UI
 * @version 0.7.0
 * Este é o core de renderização, o ponto de entrada é index.js
 */

class Skargrid {
  constructor(containerId, options = {}) {
    this.container = document.getElementById(containerId);
    if (!this.container) {
      throw new Error(`Container com ID "${containerId}" não encontrado`);
    }

    this.options = {
      data: options.data || [],
      columns: options.columns || [],
      className: options.className || 'skargrid',
      theme: options.theme || 'light', // 'light' ou 'dark'
      pagination: options.pagination !== undefined ? options.pagination : false,
      pageSize: options.pageSize || 10,
      pageSizeOptions: options.pageSizeOptions || [10, 25, 50, 100],
      sortable: options.sortable !== undefined ? options.sortable : false, // Ordenação desabilitada por padrão
      selectable: options.selectable !== undefined ? options.selectable : false,
      searchable: options.searchable !== undefined ? options.searchable : false,
      columnFilters: options.columnFilters !== undefined ? options.columnFilters : false,
      columnConfig: options.columnConfig !== undefined ? options.columnConfig : false, // Botão de configuração desabilitado por padrão
      exportCSV: options.exportCSV !== undefined ? options.exportCSV : false, // Exportar CSV desabilitado por padrão
      ...options
    };

    // Estado da paginação
    this.currentPage = 1;
    this.totalPages = 1;

    // Estado da ordenação
    this.sortColumn = null;
    this.sortDirection = null; // 'asc' ou 'desc'

    // Dados originais (não ordenados)
    this.originalData = [...this.options.data];

    // Estado da seleção - armazena índices das linhas selecionadas
    this.selectedRows = new Set();

    // Estado da busca
    this.searchText = '';
    this.filteredData = [...this.options.data];
    this.searchTimeout = null;

    // Estado dos filtros por coluna
    this.columnFilterValues = {}; // { field: value }
    this.columnFilterSelected = {}; // { field: [selectedValues] } para checkboxes

    // Estado de loading
    this.isLoading = false;

    // Referência para dropdown aberto
    this.openFilterDropdown = null;

    // Estado de visibilidade e ordem das colunas
    // Respeita a propriedade visible (padrão: true)
    this.visibleColumns = new Set(
      this.options.columns
        .filter(col => col.visible !== false)
        .map(col => col.field)
    );
    this.columnOrder = this.options.columns.map(col => col.field);

    // Inicializa features modulares
    if (typeof initColumnConfig === 'function') {
      initColumnConfig(this);
    }

    this.init();
  }

  /**
   * Obtém as colunas ordenadas e visíveis (método base, pode ser sobrescrito por features)
   */
  getOrderedVisibleColumns() {
    // Se não há controle de visibilidade, retorna todas as colunas
    if (!this.visibleColumns || !this.columnOrder) {
      return this.options.columns;
    }
    
    return this.columnOrder
      .filter(field => this.visibleColumns.has(field))
      .map(field => this.options.columns.find(col => col.field === field))
      .filter(col => col !== undefined);
  }

  /**
   * Inicializa a tabela
   */
  init() {
    this.applyFilters();
    this.calculatePagination();
    this.render();
  }

  /**
   * Calcula informações de paginação
   */
  calculatePagination() {
    if (typeof PaginationFeature !== 'undefined') {
      PaginationFeature.calculatePagination(this);
    }
  }

  /**
   * Obtém os dados da página atual
   */
  getPageData() {
    if (typeof PaginationFeature !== 'undefined') {
      return PaginationFeature.getPageData(this);
    }
    return this.filteredData;
  }

  /**
   * Renderiza a tabela completa
   */
  render(fullRender = true) {
    // Se já existe uma tabela e não precisa de render completo, faz update rápido
    if (!fullRender && this.container.querySelector('.skargrid-wrapper')) {
      this.updateTableContent();
      return;
    }

    // Limpa o container
    this.container.innerHTML = '';

    // Cria wrapper principal
    const wrapper = document.createElement('div');
    wrapper.className = 'skargrid-wrapper';
    
    // Aplica tema
    if (this.options.theme === 'dark') {
      wrapper.classList.add('skargrid-dark');
    }

    // Renderiza área superior (busca + botões de ação)
    const topBar = this.renderTopBar();
    if (topBar) {
      wrapper.appendChild(topBar);
    }

    // Container da tabela com loading
    const tableContainer = document.createElement('div');
    tableContainer.className = 'skargrid-table-container';
    
    // Adiciona indicador de loading APENAS na área da tabela
    if (this.isLoading) {
      const loadingOverlay = document.createElement('div');
      loadingOverlay.className = 'skargrid-loading-overlay';
      loadingOverlay.innerHTML = `
        <div class="skargrid-spinner">
          <svg width="40" height="40" viewBox="0 0 50 50">
            <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-dasharray="80, 200" stroke-linecap="round">
              <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
            </circle>
          </svg>
          <span>Carregando...</span>
        </div>
      `;
      tableContainer.appendChild(loadingOverlay);
    }

    // Cria o elemento da tabela
    const table = document.createElement('table');
    table.className = this.options.className;

    // Renderiza o cabeçalho
    const thead = this.renderHeader();
    table.appendChild(thead);

    // Renderiza o corpo da tabela
    const tbody = this.renderBody();
    table.appendChild(tbody);

    // Adiciona a tabela ao container
    tableContainer.appendChild(table);
    wrapper.appendChild(tableContainer);

    // Adiciona paginação se habilitada
    if (this.options.pagination) {
      const pagination = this.renderPagination();
      wrapper.appendChild(pagination);
    }

    // Adiciona tudo ao container
    this.container.appendChild(wrapper);
  }

  /**
   * Atualiza apenas o conteúdo da tabela (tbody e paginação) - mais rápido
   */
  updateTableContent() {
    const table = this.container.querySelector('.skargrid');
    if (!table) return;

    // Atualiza tbody
    const oldTbody = table.querySelector('tbody');
    const newTbody = this.renderBody();
    if (oldTbody) {
      table.replaceChild(newTbody, oldTbody);
    }

    // Atualiza header (ícones de ordenação e checkbox)
    const oldThead = table.querySelector('thead');
    const newThead = this.renderHeader();
    if (oldThead) {
      table.replaceChild(newThead, oldThead);
    }

    // Atualiza paginação
    if (this.options.pagination) {
      const oldPagination = this.container.querySelector('.skargrid-pagination');
      const newPagination = this.renderPagination();
      if (oldPagination && oldPagination.parentNode) {
        oldPagination.parentNode.replaceChild(newPagination, oldPagination);
      }
    }
  }

  /**
   * Renderiza o campo de busca
   */
  /**
   * Renderiza barra superior com busca e botões de ação
   */
  renderTopBar() {
    const hasSearch = this.options.searchable;
    const hasColumnConfig = this.options.columnConfig && typeof this.renderColumnConfigButton === 'function';
    const hasFilterClear = this.options.columnFilters;
    const hasExportCSV = this.options.exportCSV && typeof this.renderExportCSVButton === 'function';

    // Se não tem nada para renderizar, retorna null
    if (!hasSearch && !hasColumnConfig && !hasFilterClear && !hasExportCSV) {
      return null;
    }

    const searchContainer = document.createElement('div');
    searchContainer.className = 'skargrid-search-container';

    // Renderiza input de busca (se habilitado)
    if (hasSearch) {
      const searchWrapper = this.renderSearchInput();
      searchContainer.appendChild(searchWrapper);
    }

    // Renderiza botões de ação (sempre que houver algum botão)
    if (hasFilterClear || hasColumnConfig || hasExportCSV) {
      const actionsContainer = document.createElement('div');
      actionsContainer.className = 'skargrid-search-actions';

      // Botão "Limpar Filtros" (apenas se columnFilters estiver ativo)
      if (hasFilterClear) {
        const clearFiltersButton = this.renderClearFiltersButton();
        actionsContainer.appendChild(clearFiltersButton);
      }

      // Botão "Configurar Colunas" (se o módulo estiver carregado)
      if (hasColumnConfig) {
        const columnConfigBtn = this.renderColumnConfigButton();
        actionsContainer.appendChild(columnConfigBtn);
      }

      // Botão "Exportar CSV" (se o módulo estiver carregado)
      if (hasExportCSV) {
        const exportButton = this.renderExportCSVButton();
        actionsContainer.appendChild(exportButton);
      }

      searchContainer.appendChild(actionsContainer);
    }

    return searchContainer;
  }

  /**
   * Renderiza apenas o input de busca
   */
  renderSearchInput() {
    const searchWrapper = document.createElement('div');
    searchWrapper.className = 'skargrid-search-wrapper';

    // Ícone de busca (SVG profissional)
    const searchIcon = document.createElement('span');
    searchIcon.className = 'skargrid-search-icon';
    searchIcon.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
      </svg>
    `;

    // Input de busca
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'skargrid-search-input';
    searchInput.placeholder = 'Buscar em todas as colunas...';
    searchInput.value = this.searchText;
    
    // Evento de busca COM debounce (300ms) para performance
    searchInput.oninput = (e) => {
      clearTimeout(this.searchTimeout);
      this.searchTimeout = setTimeout(() => {
        this.handleSearch(e.target.value);
      }, 300);
    };

    // Botão limpar (SVG profissional)
    const clearButton = document.createElement('button');
    clearButton.className = 'skargrid-search-clear';
    clearButton.innerHTML = `
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    `;
    clearButton.style.display = this.searchText ? 'flex' : 'none';
    clearButton.onclick = () => {
      searchInput.value = '';
      searchInput.focus();
      this.handleSearch('');
    };

    searchWrapper.appendChild(searchIcon);
    searchWrapper.appendChild(searchInput);
    searchWrapper.appendChild(clearButton);

    return searchWrapper;
  }

  /**
   * Renderiza botão "Limpar Filtros"
   */
  renderClearFiltersButton() {
    const clearFiltersButton = document.createElement('button');
    clearFiltersButton.className = 'skargrid-clear-filters-btn';
    clearFiltersButton.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
        <line x1="18" y1="6" x2="6" y2="18"></line>
      </svg>
      <span class="filter-count-badge" style="display: none;">0</span>
    `;
    clearFiltersButton.title = 'Limpar Filtros';
    clearFiltersButton.onclick = () => this.clearAllFilters();
    
    // Atualiza contador de filtros ativos
    this.updateClearFiltersButton(clearFiltersButton);

    return clearFiltersButton;
  }

  /**
   * Renderiza botão "Exportar CSV"
   */
  renderExportCSVButton() {
    const exportButton = document.createElement('button');
    exportButton.className = 'skargrid-clear-filters-btn';
    exportButton.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
    `;
    exportButton.title = 'Exportar CSV';
    exportButton.onclick = () => this.exportToCSV();
    
    return exportButton;
  }

  renderSearchBox() {
    // DEPRECATED: Mantido para compatibilidade com código antigo
    // Use renderTopBar() no lugar
    return this.renderTopBar();
  }

  /**
   * Renderiza o cabeçalho da tabela
   */
  renderHeader() {
    const thead = document.createElement('thead');
    const tr = document.createElement('tr');

    // Adiciona coluna de checkbox se seleção está habilitada
    if (this.options.selectable) {
      const th = document.createElement('th');
      th.className = 'skargrid-select-header';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'skargrid-checkbox';
      checkbox.checked = this.isAllSelected();
      checkbox.onchange = (e) => this.toggleSelectAll(e.target.checked);
      
      th.appendChild(checkbox);
      tr.appendChild(th);
    }

    this.getOrderedVisibleColumns().forEach(column => {
      const th = document.createElement('th');
      th.dataset.field = column.field;

      // Verifica se a coluna é ordenável
      const isSortable = this.options.sortable && column.sortable !== false;
      const isFilterable = this.options.columnFilters && column.filterable !== false;

      if (isSortable) {
        th.classList.add('sortable');
      }

      // Container para texto e ícones
      const content = document.createElement('div');
      content.className = 'th-content';
      
      // Container de texto + sort (clicável para ordenar)
      const textSortContainer = document.createElement('div');
      textSortContainer.className = 'th-text-sort';
      if (isSortable) {
        textSortContainer.style.cursor = 'pointer';
        textSortContainer.onclick = () => this.handleSort(column.field);
        
        // Adiciona indicador de ordenação se esta coluna está ordenada
        if (this.sortColumn === column.field) {
          th.classList.add('sorted');
          th.classList.add(this.sortDirection);
        }
      }
      
      const text = document.createElement('span');
      text.className = 'th-text';
      text.textContent = column.title || column.field;
      textSortContainer.appendChild(text);

      // Adiciona ícone de ordenação se ordenável
      if (isSortable) {
        const sortIcon = document.createElement('span');
        sortIcon.className = 'sort-icon';
        
        if (this.sortColumn === column.field) {
          sortIcon.textContent = this.sortDirection === 'asc' ? '▲' : '▼';
        } else {
          sortIcon.textContent = '⇅';
        }
        
        textSortContainer.appendChild(sortIcon);
      }

      content.appendChild(textSortContainer);

      // Adiciona ícone de filtro se filtrável
      if (isFilterable) {
        const filterIconBtn = document.createElement('button');
        filterIconBtn.className = 'th-filter-btn';
        filterIconBtn.type = 'button';
        
        // Verifica se há filtro ativo nesta coluna
        const hasFilter = this.hasActiveFilter(column.field);
        if (hasFilter) {
          filterIconBtn.classList.add('has-filter');
        }
        
        filterIconBtn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
          </svg>
        `;
        
        filterIconBtn.onclick = (e) => {
          e.stopPropagation();
          this.toggleFilterDropdown(column, filterIconBtn);
        };
        
        content.appendChild(filterIconBtn);
      }

      th.appendChild(content);
      tr.appendChild(th);
    });

    thead.appendChild(tr);
    return thead;
  }

  /**
   * Verifica se uma coluna tem filtro ativo
   */
  hasActiveFilter(field) {
    if (typeof FilterFeature !== 'undefined') {
      return FilterFeature.hasActiveFilter(this, field);
    }
    return false;
  }

  /**
   * Normaliza string para busca (remove acentos)
   */
  normalizeString(str) {
    if (typeof FilterFeature !== 'undefined') {
      return FilterFeature.normalizeString(str);
    }
    // Fallback se FilterFeature não disponível
    if (!str) return '';
    return String(str)
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase();
  }

  /**
   * Obtém valores únicos de uma coluna (dados originais)
   */
  getUniqueColumnValues(field) {
    if (typeof FilterFeature !== 'undefined') {
      return FilterFeature.getUniqueColumnValues(this, field);
    }
    return [];
  }

  /**
   * Obtém valores disponíveis de uma coluna (dados filtrados, exceto a própria coluna)
   */
  getAvailableColumnValues(field) {
    if (typeof FilterFeature !== 'undefined') {
      return FilterFeature.getAvailableColumnValues(this, field);
    }
    return [];
  }

  /**
   * Abre/fecha dropdown de filtro
   */
  toggleFilterDropdown(column, buttonElement) {
    // Fecha dropdown aberto
    if (this.openFilterDropdown) {
      this.openFilterDropdown.remove();
      this.removeScrollListeners();
      if (this.openFilterDropdown.dataset.field === column.field) {
        this.openFilterDropdown = null;
        return;
      }
    }

    // Cria novo dropdown
    const dropdown = this.createFilterDropdown(column);
    dropdown.dataset.field = column.field;
    
    // Adiciona ao body para calcular tamanho e evitar ser cortado
    dropdown.style.visibility = 'hidden';
    dropdown.style.position = 'fixed';
    document.body.appendChild(dropdown);
    
    // Função para posicionar o dropdown
    const positionDropdown = () => {
      const rect = buttonElement.getBoundingClientRect();
      const dropdownRect = dropdown.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Posição inicial (logo abaixo do botão, alinhado à esquerda)
      let top = rect.bottom + 2;
      let left = rect.left;
      
      // Ajusta se sair pela direita
      if (left + dropdownRect.width > viewportWidth - 20) {
        left = rect.right - dropdownRect.width;
      }
      
      // Ajusta se sair por baixo
      if (top + dropdownRect.height > viewportHeight - 20) {
        // Abre para cima
        top = rect.top - dropdownRect.height - 2;
      }
      
      // Garante que não saia pela esquerda
      if (left < 10) {
        left = 10;
      }
      
      dropdown.style.top = `${top}px`;
      dropdown.style.left = `${left}px`;
    };
    
    // Posiciona inicialmente
    positionDropdown();
    dropdown.style.visibility = 'visible';
    
    this.openFilterDropdown = dropdown;

    // Handler para reposicionar no scroll
    const scrollHandler = () => {
      positionDropdown();
    };
    
    // Adiciona listeners de scroll
    window.addEventListener('scroll', scrollHandler, true); // true = capture phase para pegar todos scrolls
    this.scrollHandler = scrollHandler;

    // Fecha ao clicar fora
    setTimeout(() => {
      document.addEventListener('click', (e) => {
        if (!dropdown.contains(e.target) && e.target !== buttonElement) {
          dropdown.remove();
          this.removeScrollListeners();
          this.openFilterDropdown = null;
        }
      }, { once: true });
    }, 100);
  }

  /**
   * Remove listeners de scroll
   */
  removeScrollListeners() {
    if (this.scrollHandler) {
      window.removeEventListener('scroll', this.scrollHandler, true);
      this.scrollHandler = null;
    }
  }

  /**
   * Cria dropdown de filtro profissional
   */
  createFilterDropdown(column) {
    const dropdown = document.createElement('div');
    dropdown.className = 'skargrid-filter-dropdown';

    const filterType = column.filterType || 'text';

    if (filterType === 'select') {
      // Dropdown com checkboxes
      this.createCheckboxFilter(dropdown, column);
    } else {
      // Input simples para text, number, date
      this.createInputFilter(dropdown, column, filterType);
    }

    return dropdown;
  }

  /**
   * Cria filtro com checkboxes e busca interna (valores disponíveis dinamicamente)
   */
  createCheckboxFilter(dropdown, column) {
    // Pega TODOS os valores que existem nos dados originais
    const allUniqueValues = this.getUniqueColumnValues(column.field);
    
    // Pega valores DISPONÍVEIS considerando outros filtros ativos
    const availableValues = this.getAvailableColumnValues(column.field);
    
    // Inicializa selected se não existir (com todos os valores originais)
    if (!this.columnFilterSelected[column.field]) {
      this.columnFilterSelected[column.field] = [...allUniqueValues];
    }

    // Header do dropdown
    const header = document.createElement('div');
    header.className = 'filter-dropdown-header';
    header.innerHTML = `<strong>Filtrar: ${column.title || column.field}</strong>`;
    dropdown.appendChild(header);

    // Campo de busca interno
    const searchWrapper = document.createElement('div');
    searchWrapper.className = 'filter-search-wrapper';
    
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'filter-search-input';
    searchInput.placeholder = 'Buscar...';
    
    searchWrapper.appendChild(searchInput);
    dropdown.appendChild(searchWrapper);

    // Select All / Deselect All
    const selectAllWrapper = document.createElement('div');
    selectAllWrapper.className = 'filter-select-all';
    
    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.id = `select-all-${column.field}`;
    selectAllCheckbox.checked = this.columnFilterSelected[column.field].length === allUniqueValues.length;
    
    const selectAllLabel = document.createElement('label');
    selectAllLabel.htmlFor = `select-all-${column.field}`;
    selectAllLabel.textContent = 'Selecionar Todos';
    
    selectAllWrapper.appendChild(selectAllCheckbox);
    selectAllWrapper.appendChild(selectAllLabel);
    dropdown.appendChild(selectAllWrapper);

    // Lista de checkboxes com scroll
    const listWrapper = document.createElement('div');
    listWrapper.className = 'filter-list-wrapper';
    
    const list = document.createElement('div');
    list.className = 'filter-list';

    const renderList = (filteredValues = allUniqueValues) => {
      list.innerHTML = '';
      filteredValues.forEach(value => {
        const item = document.createElement('div');
        item.className = 'filter-list-item';
        
        // Verifica se o valor está disponível nos dados filtrados
        const isAvailable = availableValues.includes(value);
        if (!isAvailable) {
          item.classList.add('filter-item-disabled');
          item.title = 'Não disponível com os filtros atuais';
        }
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = value;
        checkbox.id = `filter-${column.field}-${value}`;
        checkbox.checked = this.columnFilterSelected[column.field].includes(value);
        checkbox.disabled = !isAvailable; // Desabilita se não disponível
        
        const label = document.createElement('label');
        label.htmlFor = `filter-${column.field}-${value}`;
        label.textContent = value;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        list.appendChild(item);

        // Toggle individual
        checkbox.onchange = () => {
          if (checkbox.checked) {
            if (!this.columnFilterSelected[column.field].includes(value)) {
              this.columnFilterSelected[column.field].push(value);
            }
          } else {
            this.columnFilterSelected[column.field] = 
              this.columnFilterSelected[column.field].filter(v => v !== value);
          }
          selectAllCheckbox.checked = 
            this.columnFilterSelected[column.field].length === allUniqueValues.length;
        };
      });
    };

    renderList();
    listWrapper.appendChild(list);
    dropdown.appendChild(listWrapper);

    // Busca interna (com normalização de acentos)
    searchInput.oninput = (e) => {
      const searchTerm = this.normalizeString(e.target.value);
      const filtered = allUniqueValues.filter(val => 
        this.normalizeString(val).includes(searchTerm)
      );
      renderList(filtered);
    };

    // Select/Deselect All
    selectAllCheckbox.onchange = () => {
      if (selectAllCheckbox.checked) {
        this.columnFilterSelected[column.field] = [...allUniqueValues];
      } else {
        this.columnFilterSelected[column.field] = [];
      }
      renderList();
    };

    // Footer com botões
    const footer = document.createElement('div');
    footer.className = 'filter-dropdown-footer';
    
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'Limpar';
    clearBtn.className = 'filter-btn-clear';
    clearBtn.onclick = () => {
      this.columnFilterSelected[column.field] = [...allUniqueValues];
      this.handleColumnFilterCheckbox(column.field);
      dropdown.remove();
      this.removeScrollListeners();
      this.openFilterDropdown = null;
    };
    
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Aplicar';
    applyBtn.className = 'filter-btn-apply';
    applyBtn.onclick = () => {
      this.handleColumnFilterCheckbox(column.field);
      dropdown.remove();
      this.removeScrollListeners();
      this.openFilterDropdown = null;
    };
    
    footer.appendChild(clearBtn);
    footer.appendChild(applyBtn);
    dropdown.appendChild(footer);
  }

  /**
   * Cria filtro com input simples
   */
  createInputFilter(dropdown, column, filterType) {
    const header = document.createElement('div');
    header.className = 'filter-dropdown-header';
    header.innerHTML = `<strong>Filtrar: ${column.title || column.field}</strong>`;
    dropdown.appendChild(header);

    const inputWrapper = document.createElement('div');
    inputWrapper.className = 'filter-input-wrapper';
    
    const input = document.createElement('input');
    input.type = filterType === 'number' ? 'number' : filterType === 'date' ? 'date' : 'text';
    input.className = 'filter-dropdown-input';
    input.placeholder = `Digite para filtrar...`;
    input.value = this.columnFilterValues[column.field] || '';
    
    inputWrapper.appendChild(input);
    dropdown.appendChild(inputWrapper);

    const footer = document.createElement('div');
    footer.className = 'filter-dropdown-footer';
    
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'Limpar';
    clearBtn.className = 'filter-btn-clear';
    clearBtn.onclick = () => {
      this.handleColumnFilter(column.field, '');
      dropdown.remove();
      this.openFilterDropdown = null;
    };
    
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Aplicar';
    applyBtn.className = 'filter-btn-apply';
    applyBtn.onclick = () => {
      this.handleColumnFilter(column.field, input.value);
      dropdown.remove();
      this.openFilterDropdown = null;
    };
    
    footer.appendChild(clearBtn);
    footer.appendChild(applyBtn);
    dropdown.appendChild(footer);

    // Aplica ao pressionar Enter
    input.onkeypress = (e) => {
      if (e.key === 'Enter') {
        applyBtn.click();
      }
    };

    // Foco automático
    setTimeout(() => input.focus(), 100);
  }

  /**
   * Manipula filtro de checkbox (select)
   */
  handleColumnFilterCheckbox(field) {
    const allValues = this.getUniqueColumnValues(field);
    const selected = this.columnFilterSelected[field] || [];
    
    // Se todos estão selecionados, não filtra
    if (selected.length === allValues.length) {
      delete this.columnFilterValues[field];
    } else {
      this.columnFilterValues[field] = selected;
    }
    
    this.currentPage = 1;
    this.applyFilters();
    this.calculatePagination();
    this.render(false);
    this.updateClearFiltersButton();
  }

  /**
   * Renderiza o corpo da tabela
   */
  renderBody() {
    const tbody = document.createElement('tbody');
    const pageData = this.getPageData();

    pageData.forEach((row, pageIndex) => {
      // Calcula o índice global do registro
      const globalIndex = this.options.pagination
        ? (this.currentPage - 1) * this.options.pageSize + pageIndex
        : pageIndex;

      const tr = document.createElement('tr');
      tr.dataset.index = globalIndex;

      // Adiciona classe se a linha está selecionada
      if (this.selectedRows.has(globalIndex)) {
        tr.classList.add('selected');
      }

      // Adiciona coluna de checkbox se seleção está habilitada
      if (this.options.selectable) {
        const td = document.createElement('td');
        td.className = 'skargrid-select-cell';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'skargrid-checkbox';
        checkbox.checked = this.selectedRows.has(globalIndex);
        checkbox.onchange = (e) => {
          e.stopPropagation();
          this.toggleSelectRow(globalIndex, e.target.checked);
        };
        
        td.appendChild(checkbox);
        tr.appendChild(td);

        // Adiciona clique na linha para selecionar
        tr.style.cursor = 'pointer';
        tr.onclick = (e) => {
          // Ignora clique no checkbox
          if (e.target.type !== 'checkbox') {
            checkbox.checked = !checkbox.checked;
            this.toggleSelectRow(globalIndex, checkbox.checked);
          }
        };
      }

      this.getOrderedVisibleColumns().forEach(column => {
        const td = document.createElement('td');
        const value = row[column.field];
        
        // Permite formatação customizada
        if (column.formatter && typeof column.formatter === 'function') {
          td.innerHTML = column.formatter(value, row, globalIndex);
        } else {
          td.textContent = value !== undefined && value !== null ? value : '';
        }

        td.dataset.field = column.field;
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    return tbody;
  }

  /**
   * Renderiza os controles de paginação
   */
  renderPagination() {
    if (typeof PaginationFeature !== 'undefined') {
      return PaginationFeature.renderPagination(this);
    }
    return document.createElement('div');
  }

  /**
   * Navega para uma página específica
   */
  goToPage(pageNumber) {
    if (typeof PaginationFeature !== 'undefined') {
      PaginationFeature.goToPage(this, pageNumber);
    }
  }

  /**
   * Muda o número de itens por página
   */
  changePageSize(newSize) {
    if (typeof PaginationFeature !== 'undefined') {
      PaginationFeature.changePageSize(this, newSize);
    }
  }

  /**
   * Atualiza os dados da tabela
   */
  updateData(newData) {
    this.options.data = newData;
    this.originalData = [...newData];
    this.currentPage = 1;
    this.sortColumn = null;
    this.sortDirection = null;
    this.selectedRows.clear();  // Limpa seleções ao atualizar dados
    this.searchText = '';
    this.applyFilters();
    this.calculatePagination();
    this.render();
  }

  /**
   * Manipula a busca de texto
   */
  handleSearch(searchText) {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.handleSearch(this, searchText);
    }
  }

  /**
   * Manipula filtro por coluna
   */
  handleColumnFilter(field, value) {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.handleColumnFilter(this, field, value);
    }
  }

  /**
   * Limpa todos os filtros de coluna
   */
  clearColumnFilters() {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.clearColumnFilters(this);
    }
  }

  /**
   * Limpa TODOS os filtros (busca + filtros de coluna)
   */
  clearAllFilters() {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.clearAllFilters(this);
    }
  }

  /**
   * Atualiza o botão de limpar filtros com contador de filtros ativos
   */
  updateClearFiltersButton(button = null) {
    if (!button) {
      button = this.container.querySelector('.skargrid-clear-filters-btn');
    }
    
    if (!button) return;
    
    // Conta quantos filtros estão ativos
    let activeCount = 0;
    
    // Conta busca global
    if (this.searchText) activeCount++;
    
    // Conta filtros de coluna
    this.options.columns.forEach(column => {
      if (column.filterable !== false) {
        if (this.hasActiveFilter(column.field)) {
          activeCount++;
        }
      }
    });
    
    const badge = button.querySelector('.filter-count-badge');
    if (activeCount > 0) {
      badge.textContent = activeCount;
      badge.style.display = 'flex';
      button.classList.add('has-filters');
    } else {
      badge.style.display = 'none';
      button.classList.remove('has-filters');
    }
  }

  /**
   * Aplica filtros (busca + filtros de coluna) aos dados
   */
  applyFilters() {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.applyFilters(this);
    }
  }

  /**
   * Limpa a busca
   */
  clearSearch() {
    if (typeof FilterFeature !== 'undefined') {
      FilterFeature.clearSearch(this);
    }
  }

  /**
   * Manipula o clique em uma coluna para ordenação
   */
  handleSort(field) {
    if (typeof SortFeature !== 'undefined') {
      SortFeature.handleSort(this, field);
    }
  }

  /**
   * Ordena os dados pela coluna e direção atuais
   */
  sortData() {
    if (typeof SortFeature !== 'undefined') {
      SortFeature.sortData(this);
    }
  }

  /**
   * Remove a ordenação e restaura a ordem original
   */
  clearSort() {
    this.sortColumn = null;
    this.sortDirection = null;
    this.options.data = [...this.originalData];
    this.currentPage = 1;
    this.applyFilters();
    this.calculatePagination();
    this.render();
  }

  /**
   * Obtém os dados atuais
   */
  getData() {
    return this.options.data;
  }

  /**
   * Alterna a seleção de uma linha específica
   */
  toggleSelectRow(index, selected) {
    if (typeof SelectionFeature !== 'undefined') {
      SelectionFeature.toggleSelectRow(this, index, selected);
    }
  }

  /**
   * Seleciona ou desseleciona todas as linhas
   */
  toggleSelectAll(selected) {
    if (typeof SelectionFeature !== 'undefined') {
      SelectionFeature.toggleSelectAll(this, selected);
    }
  }

  /**
   * Verifica se todas as linhas estão selecionadas
   */
  isAllSelected() {
    if (typeof SelectionFeature !== 'undefined') {
      return SelectionFeature.isAllSelected(this);
    }
    return false;
  }

  /**
   * Seleciona linhas específicas por índices
   */
  selectRows(indices) {
    if (typeof SelectionFeature !== 'undefined') {
      SelectionFeature.selectRows(this, indices);
    }
  }

  /**
   * Desseleciona linhas específicas por índices
   */
  deselectRows(indices) {
    if (typeof SelectionFeature !== 'undefined') {
      SelectionFeature.deselectRows(this, indices);
    }
  }

  /**
   * Limpa todas as seleções
   */
  clearSelection() {
    if (typeof SelectionFeature !== 'undefined') {
      SelectionFeature.clearSelection(this);
    }
  }

  /**
   * Obtém os dados das linhas selecionadas
   */
  getSelectedRows() {
    if (typeof SelectionFeature !== 'undefined') {
      return SelectionFeature.getSelectedRows(this);
    }
    return [];
  }

  /**
   * Obtém os índices das linhas selecionadas
   */
  getSelectedIndices() {
    if (typeof SelectionFeature !== 'undefined') {
      return SelectionFeature.getSelectedIndices(this);
    }
    return [];
  }

  /**
   * Mostra indicador de loading
   */
  showLoading() {
    this.isLoading = true;
  }

  /**
   * Esconde indicador de loading
   */
  hideLoading() {
    this.isLoading = false;
  }

  /**
   * Destroi a instância da tabela
   */
  destroy() {
    this.container.innerHTML = '';
  }

  /**
   * Altera o tema da tabela dinamicamente
   * @param {string} theme - 'light' ou 'dark'
   */
  setTheme(theme) {
    if (theme !== 'light' && theme !== 'dark') {
      console.warn(`Tema inválido: ${theme}. Use 'light' ou 'dark'.`);
      return;
    }

    this.options.theme = theme;
    
    const wrapper = this.container.querySelector('.skargrid-wrapper');
    if (!wrapper) {
      console.warn('Wrapper não encontrado. A tabela foi renderizada?');
      return;
    }

    if (theme === 'dark') {
      wrapper.classList.add('skargrid-dark');
    } else {
      wrapper.classList.remove('skargrid-dark');
    }
  }
}

// Exporta para uso global como Skargrid (implementação)


// UMD/Global export para browser


/**
 * Skargrid - Módulo de Paginação
 * Gerencia navegação entre páginas e tamanho de página
 */

const PaginationFeature = {
  /**
   * Renderiza componente completo de paginação
   */
  renderPagination(grid) {
    const paginationDiv = document.createElement('div');
    paginationDiv.className = 'skargrid-pagination';

    // Info de registros
    const info = this.renderPaginationInfo(grid);
    paginationDiv.appendChild(info);

    // Controles de navegação
    const controls = this.renderPaginationControls(grid);
    paginationDiv.appendChild(controls);

    // Seletor de itens por página
    const sizeSelector = this.renderPageSizeSelector(grid);
    paginationDiv.appendChild(sizeSelector);

    return paginationDiv;
  },

  /**
   * Renderiza informação sobre registros exibidos
   */
  renderPaginationInfo(grid) {
    const info = document.createElement('div');
    info.className = 'skargrid-pagination-info';

    const totalRecords = grid.filteredData.length;
    const totalOriginal = grid.options.data.length;
    const startRecord = totalRecords === 0 ? 0 : (grid.currentPage - 1) * grid.options.pageSize + 1;
    const endRecord = Math.min(grid.currentPage * grid.options.pageSize, totalRecords);

    let text = `Mostrando ${startRecord} até ${endRecord} de ${totalRecords} registros`;
    
    // Adiciona info de filtro se houver busca ativa
    if (grid.searchText && totalRecords < totalOriginal) {
      text += ` (filtrados de ${totalOriginal} total)`;
    }

    info.textContent = text;
    return info;
  },

  /**
   * Renderiza controles de navegação (anterior/próximo)
   */
  renderPaginationControls(grid) {
    const controls = document.createElement('div');
    controls.className = 'skargrid-pagination-controls';

    // Botão Primeira Página
    const firstBtn = document.createElement('button');
    firstBtn.textContent = '«';
    firstBtn.className = 'skargrid-pagination-btn';
    firstBtn.disabled = grid.currentPage === 1;
    firstBtn.onclick = () => this.goToPage(grid, 1);
    controls.appendChild(firstBtn);

    // Botão Anterior
    const prevBtn = document.createElement('button');
    prevBtn.textContent = '‹';
    prevBtn.className = 'skargrid-pagination-btn';
    prevBtn.disabled = grid.currentPage === 1;
    prevBtn.onclick = () => this.goToPage(grid, grid.currentPage - 1);
    controls.appendChild(prevBtn);

    // Números de página
    const pageNumbers = this.getPageNumbers(grid);
    pageNumbers.forEach(pageNum => {
      if (pageNum === '...') {
        const ellipsis = document.createElement('span');
        ellipsis.textContent = '...';
        ellipsis.className = 'skargrid-pagination-ellipsis';
        controls.appendChild(ellipsis);
      } else {
        const pageBtn = document.createElement('button');
        pageBtn.textContent = pageNum;
        pageBtn.className = 'skargrid-pagination-btn';
        if (pageNum === grid.currentPage) {
          pageBtn.classList.add('active');
        }
        pageBtn.onclick = () => this.goToPage(grid, pageNum);
        controls.appendChild(pageBtn);
      }
    });

    // Botão Próximo
    const nextBtn = document.createElement('button');
    nextBtn.textContent = '›';
    nextBtn.className = 'skargrid-pagination-btn';
    nextBtn.disabled = grid.currentPage === grid.totalPages;
    nextBtn.onclick = () => this.goToPage(grid, grid.currentPage + 1);
    controls.appendChild(nextBtn);

    // Botão Última Página
    const lastBtn = document.createElement('button');
    lastBtn.textContent = '»';
    lastBtn.className = 'skargrid-pagination-btn';
    lastBtn.disabled = grid.currentPage === grid.totalPages;
    lastBtn.onclick = () => this.goToPage(grid, grid.totalPages);
    controls.appendChild(lastBtn);

    return controls;
  },

  /**
   * Calcula quais números de página devem ser exibidos
   */
  getPageNumbers(grid) {
    const pages = [];
    const maxVisible = 5;

    if (grid.totalPages <= maxVisible + 2) {
      // Mostra todas as páginas
      for (let i = 1; i <= grid.totalPages; i++) {
        pages.push(i);
      }
    } else {
      // Mostra primeira, última e páginas ao redor da atual
      pages.push(1);

      let start = Math.max(2, grid.currentPage - 1);
      let end = Math.min(grid.totalPages - 1, grid.currentPage + 1);

      if (grid.currentPage <= 3) {
        end = 4;
      } else if (grid.currentPage >= grid.totalPages - 2) {
        start = grid.totalPages - 3;
      }

      if (start > 2) pages.push('...');

      for (let i = start; i <= end; i++) {
        pages.push(i);
      }

      if (end < grid.totalPages - 1) pages.push('...');

      pages.push(grid.totalPages);
    }

    return pages;
  },

  /**
   * Renderiza seletor de itens por página
   */
  renderPageSizeSelector(grid) {
    const selector = document.createElement('div');
    selector.className = 'skargrid-page-size';

    const label = document.createElement('span');
    label.textContent = 'Itens por página: ';
    selector.appendChild(label);

    const select = document.createElement('select');
    select.className = 'skargrid-page-size-select';

    grid.options.pageSizeOptions.forEach(size => {
      const option = document.createElement('option');
      option.value = size;
      option.textContent = size;
      if (size === grid.options.pageSize) {
        option.selected = true;
      }
      select.appendChild(option);
    });

    select.onchange = (e) => {
      this.changePageSize(grid, parseInt(e.target.value));
    };

    selector.appendChild(select);
    return selector;
  },

  /**
   * Navega para uma página específica
   */
  goToPage(grid, pageNumber) {
    if (pageNumber < 1 || pageNumber > grid.totalPages) {
      return;
    }
    grid.currentPage = pageNumber;
    grid.render(false); // Update rápido
  },

  /**
   * Muda o número de itens por página
   */
  changePageSize(grid, newSize) {
    grid.options.pageSize = newSize;
    grid.currentPage = 1;
    grid.calculatePagination();
    grid.render(false); // Update rápido
  },

  /**
   * Calcula paginação
   */
  calculatePagination(grid) {
    const totalRecords = grid.filteredData.length;
    grid.totalPages = Math.ceil(totalRecords / grid.options.pageSize) || 1;
    
    // Ajusta página atual se estiver fora do range
    if (grid.currentPage > grid.totalPages) {
      grid.currentPage = grid.totalPages;
    }
  },

  /**
   * Retorna dados da página atual
   */
  getPageData(grid) {
    if (!grid.options.pagination) {
      return grid.filteredData;
    }

    const startIndex = (grid.currentPage - 1) * grid.options.pageSize;
    const endIndex = startIndex + grid.options.pageSize;
    return grid.filteredData.slice(startIndex, endIndex);
  }
};

// Exporta para uso global


/**
 * Skargrid - Módulo de Ordenação
 * Gerencia ordenação de colunas (ASC/DESC/None)
 */

const SortFeature = {
  /**
   * Manipula clique em coluna para ordenar
   */
  handleSort(grid, field) {
    // Se já está ordenando por esta coluna, inverte a direção
    if (grid.sortColumn === field) {
      if (grid.sortDirection === 'asc') {
        grid.sortDirection = 'desc';
      } else if (grid.sortDirection === 'desc') {
        // Terceiro clique remove a ordenação
        grid.sortColumn = null;
        grid.sortDirection = null;
        grid.options.data = [...grid.originalData];
      }
    } else {
      // Nova coluna, começa com ascendente
      grid.sortColumn = field;
      grid.sortDirection = 'asc';
    }

    // Aplica a ordenação se houver coluna selecionada
    if (grid.sortColumn) {
      this.sortData(grid);
    }

    // Volta para a primeira página após ordenar
    grid.currentPage = 1;
    grid.calculatePagination();
    grid.render(false); // Update rápido
  },

  /**
   * Ordena os dados pela coluna e direção atuais
   */
  sortData(grid) {
    const column = grid.options.columns.find(col => col.field === grid.sortColumn);
    
    grid.options.data.sort((a, b) => {
      let valueA = a[grid.sortColumn];
      let valueB = b[grid.sortColumn];

      // Aplica função de comparação customizada se existir
      if (column && column.sortCompare && typeof column.sortCompare === 'function') {
        return grid.sortDirection === 'asc' 
          ? column.sortCompare(valueA, valueB, a, b)
          : column.sortCompare(valueB, valueA, b, a);
      }

      // Tratamento de valores nulos/undefined
      if (valueA == null) valueA = '';
      if (valueB == null) valueB = '';

      // Detecta o tipo de dado e ordena apropriadamente
      if (typeof valueA === 'number' && typeof valueB === 'number') {
        // Ordenação numérica
        return grid.sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
      } else {
        // Ordenação de string (case-insensitive)
        const strA = String(valueA).toLowerCase();
        const strB = String(valueB).toLowerCase();
        
        if (grid.sortDirection === 'asc') {
          return strA.localeCompare(strB);
        } else {
          return strB.localeCompare(strA);
        }
      }
    });

    // Reaplica filtros após ordenar
    grid.applyFilters();
  },

  /**
   * Renderiza ícone de ordenação no header
   */
  renderSortIcon(grid, field) {
    const icon = document.createElement('span');
    icon.className = 'sort-icon';
    
    if (grid.sortColumn === field) {
      icon.textContent = grid.sortDirection === 'asc' ? '▲' : '▼';
    } else {
      icon.textContent = '⇅';
    }
    
    return icon;
  }
};

// Exporta para uso global


/**
 * Skargrid - Módulo de Seleção
 * Gerencia checkbox e seleção múltipla de linhas
 */

const SelectionFeature = {
  /**
   * Alterna seleção de uma linha específica
   */
  toggleSelectRow(grid, index, selected) {
    if (selected) {
      grid.selectedRows.add(index);
    } else {
      grid.selectedRows.delete(index);
    }
    grid.render(false); // Update rápido
  },

  /**
   * Seleciona ou desseleciona todas as linhas
   */
  toggleSelectAll(grid, selected) {
    if (selected) {
      // Seleciona todas as linhas
      grid.options.data.forEach((_, index) => {
        grid.selectedRows.add(index);
      });
    } else {
      // Desseleciona todas
      grid.selectedRows.clear();
    }
    grid.render(false); // Update rápido
  },

  /**
   * Verifica se todas as linhas estão selecionadas
   */
  isAllSelected(grid) {
    if (grid.options.data.length === 0) return false;
    return grid.selectedRows.size === grid.options.data.length;
  },

  /**
   * Seleciona linhas específicas por índices
   */
  selectRows(grid, indices) {
    indices.forEach(index => {
      if (index >= 0 && index < grid.options.data.length) {
        grid.selectedRows.add(index);
      }
    });
    grid.render();
  },

  /**
   * Desseleciona linhas específicas por índices
   */
  deselectRows(grid, indices) {
    indices.forEach(index => {
      grid.selectedRows.delete(index);
    });
    grid.render();
  },

  /**
   * Limpa todas as seleções
   */
  clearSelection(grid) {
    grid.selectedRows.clear();
    grid.render();
  },

  /**
   * Obtém os dados das linhas selecionadas
   */
  getSelectedRows(grid) {
    return Array.from(grid.selectedRows)
      .map(index => grid.options.data[index])
      .filter(row => row !== undefined);
  },

  /**
   * Obtém os índices das linhas selecionadas
   */
  getSelectedIndices(grid) {
    return Array.from(grid.selectedRows).sort((a, b) => a - b);
  },

  /**
   * Renderiza checkbox no header (selecionar todos)
   */
  renderSelectAllCheckbox(grid) {
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'skargrid-checkbox';
    checkbox.checked = this.isAllSelected(grid);
    checkbox.onchange = (e) => this.toggleSelectAll(grid, e.target.checked);
    return checkbox;
  },

  /**
   * Renderiza checkbox em uma célula de dados
   */
  renderRowCheckbox(grid, globalIndex) {
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'skargrid-checkbox';
    checkbox.checked = grid.selectedRows.has(globalIndex);
    checkbox.onchange = (e) => {
      e.stopPropagation();
      this.toggleSelectRow(grid, globalIndex, e.target.checked);
    };
    return checkbox;
  }
};

// Exporta para uso global


/**
 * Skargrid - Módulo de Filtros
 * Gerencia busca global e filtros por coluna
 */

const FilterFeature = {
  /**
   * Normaliza string removendo acentos para busca
   */
  normalizeString(str) {
    if (!str) return '';
    return String(str)
      .normalize('NFD') // Decompõe caracteres acentuados
      .replace(/[\u0300-\u036f]/g, '') // Remove marcas diacríticas
      .toLowerCase();
  },

  /**
   * Aplica todos os filtros (busca + filtros de coluna)
   */
  applyFilters(grid) {
    let filtered = [...grid.options.data];

    // Aplica busca global se houver texto
    if (grid.searchText) {
      const searchNormalized = this.normalizeString(grid.searchText);
      
      filtered = filtered.filter(row => {
        // Busca em todas as colunas
        return grid.options.columns.some(column => {
          const value = row[column.field];
          if (value == null) return false;
          
          // Normaliza valor e compara sem acentos
          const valueNormalized = this.normalizeString(value);
          return valueNormalized.includes(searchNormalized);
        });
      });
    }

    // Aplica filtros por coluna
    if (Object.keys(grid.columnFilterValues).length > 0) {
      filtered = filtered.filter(row => {
        // Todas as condições de filtro devem ser atendidas (AND)
        return Object.entries(grid.columnFilterValues).every(([field, filterValue]) => {
          const cellValue = row[field];
          
          const column = grid.options.columns.find(col => col.field === field);
          const filterType = column?.filterType || 'text';

          // Filtro por tipo
          if (filterType === 'select') {
            // Array de valores selecionados (checkboxes)
            if (Array.isArray(filterValue)) {
              return filterValue.includes(cellValue);
            }
            return String(cellValue) === String(filterValue);
          } else if (filterType === 'number') {
            if (!filterValue) return true;
            if (cellValue == null) return false;
            return Number(cellValue) === Number(filterValue);
          } else if (filterType === 'date') {
            if (!filterValue) return true;
            if (cellValue == null) return false;
            return String(cellValue).startsWith(filterValue);
          } else {
            // text - busca parcial case-insensitive com normalização
            if (!filterValue) return true;
            if (cellValue == null) return false;
            const cellNormalized = this.normalizeString(cellValue);
            const filterNormalized = this.normalizeString(filterValue);
            return cellNormalized.includes(filterNormalized);
          }
        });
      });
    }

    grid.filteredData = filtered;
  },

  /**
   * Manipula a busca de texto
   */
  handleSearch(grid, searchText) {
    grid.searchText = searchText.trim();
    grid.currentPage = 1;
    
    // Fecha dropdown aberto (evita bug de posicionamento)
    if (grid.openFilterDropdown) {
      grid.openFilterDropdown.remove();
      grid.openFilterDropdown = null;
      if (grid.removeScrollListeners) {
        grid.removeScrollListeners();
      }
    }
    
    // Aplica filtros e renderiza de forma otimizada
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render(false); // false = update rápido
    grid.updateClearFiltersButton();
  },

  /**
   * Limpa a busca
   */
  clearSearch(grid) {
    grid.searchText = '';
    grid.currentPage = 1;
    
    // Fecha dropdown aberto
    if (grid.openFilterDropdown) {
      grid.openFilterDropdown.remove();
      grid.openFilterDropdown = null;
      if (grid.removeScrollListeners) {
        grid.removeScrollListeners();
      }
    }
    
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render();
  },

  /**
   * Manipula filtro por coluna (text/number/date)
   */
  handleColumnFilter(grid, field, value) {
    if (value) {
      grid.columnFilterValues[field] = value;
    } else {
      delete grid.columnFilterValues[field];
    }
    
    grid.currentPage = 1;
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render(false);
    grid.updateClearFiltersButton();
  },

  /**
   * Manipula filtro de checkbox (select)
   */
  handleColumnFilterCheckbox(grid, field) {
    const allValues = this.getUniqueColumnValues(grid, field);
    const selected = grid.columnFilterSelected[field] || [];
    
    // Se todos estão selecionados, não filtra
    if (selected.length === allValues.length) {
      delete grid.columnFilterValues[field];
    } else {
      grid.columnFilterValues[field] = selected;
    }
    
    grid.currentPage = 1;
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render(false);
    grid.updateClearFiltersButton();
  },

  /**
   * Limpa todos os filtros de coluna
   */
  clearColumnFilters(grid) {
    grid.columnFilterValues = {};
    grid.currentPage = 1;
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render(false);
  },

  /**
   * Limpa TODOS os filtros (busca + filtros de coluna)
   */
  clearAllFilters(grid) {
    // Limpa busca global
    grid.searchText = '';
    const searchInput = grid.container.querySelector('.skargrid-search-input');
    if (searchInput) {
      searchInput.value = '';
    }
    
    // Limpa filtros de coluna
    grid.columnFilterValues = {};
    grid.columnFilterSelected = {};
    
    // Reseta valores padrão para select types
    grid.options.columns.forEach(column => {
      if (column.filterable !== false && column.filterType === 'select') {
        const uniqueValues = this.getUniqueColumnValues(grid, column.field);
        grid.columnFilterSelected[column.field] = [...uniqueValues];
      }
    });
    
    // Fecha dropdown aberto
    if (grid.openFilterDropdown) {
      grid.openFilterDropdown.remove();
      grid.openFilterDropdown = null;
    }
    
    // Remove listeners de scroll
    if (grid.removeScrollListeners) {
      grid.removeScrollListeners();
    }
    
    grid.currentPage = 1;
    this.applyFilters(grid);
    grid.calculatePagination();
    grid.render();
  },

  /**
   * Obtém valores únicos de uma coluna (dos dados originais)
   */
  getUniqueColumnValues(grid, field) {
    const values = grid.options.data
      .map(row => row[field])
      .filter(value => value != null);
    
    return [...new Set(values)].sort();
  },

  /**
   * Obtém valores disponíveis de uma coluna baseado nos dados filtrados
   * (exclui o filtro da própria coluna para mostrar o que está disponível)
   */
  getAvailableColumnValues(grid, field) {
    // Pega dados filtrados, mas IGNORANDO o filtro da coluna atual
    let data = [...grid.options.data];

    // Aplica busca global
    if (grid.searchText) {
      const searchNormalized = this.normalizeString(grid.searchText);
      data = data.filter(row => {
        return grid.options.columns.some(column => {
          const value = row[column.field];
          if (value == null) return false;
          const valueNormalized = this.normalizeString(value);
          return valueNormalized.includes(searchNormalized);
        });
      });
    }

    // Aplica filtros de OUTRAS colunas (não a atual)
    if (Object.keys(grid.columnFilterValues).length > 0) {
      data = data.filter(row => {
        return Object.entries(grid.columnFilterValues).every(([filterField, filterValue]) => {
          // Ignora o filtro da coluna atual
          if (filterField === field) return true;
          
          const cellValue = row[filterField];
          const column = grid.options.columns.find(col => col.field === filterField);
          const filterType = column?.filterType || 'text';

          if (filterType === 'select') {
            if (Array.isArray(filterValue)) {
              return filterValue.includes(cellValue);
            }
            return String(cellValue) === String(filterValue);
          } else if (filterType === 'number') {
            if (!filterValue) return true;
            if (cellValue == null) return false;
            return Number(cellValue) === Number(filterValue);
          } else if (filterType === 'date') {
            if (!filterValue) return true;
            if (cellValue == null) return false;
            return String(cellValue).startsWith(filterValue);
          } else {
            if (!filterValue) return true;
            if (cellValue == null) return false;
            const cellNormalized = this.normalizeString(cellValue);
            const filterNormalized = this.normalizeString(filterValue);
            return cellNormalized.includes(filterNormalized);
          }
        });
      });
    }

    // Extrai valores únicos da coluna nos dados filtrados
    const values = data
      .map(row => row[field])
      .filter(value => value != null);
    
    return [...new Set(values)].sort();
  },

  /**
   * Verifica se uma coluna tem filtro ativo
   * @returns {boolean} true se há filtro ativo (nem todos valores estão selecionados)
   */
  hasActiveFilter(grid, field) {
    const column = grid.options.columns.find(col => col.field === field);
    if (!column || column.filterable === false) return false;

    if (column.filterType === 'select') {
      const allValues = this.getUniqueColumnValues(grid, field);
      const selected = grid.columnFilterSelected[field];
      
      // Se não foi inicializado ainda, considera sem filtro
      if (!selected || selected.length === 0) return false;
      
      // Se todos estão selecionados, não há filtro
      // Se algum foi desmarcado, há filtro ativo
      return selected.length < allValues.length;
    } else {
      // Para text, number, date: há filtro se tem valor
      return !!grid.columnFilterValues[field];
    }
  }
};

// Exporta para uso global


/**
 * Skargrid - Column Configuration Feature
 * Funcionalidade para mostrar/ocultar e reordenar colunas
 */

function initColumnConfig(grid) {
  // Estado temporário para configuração
  grid.tempVisibleColumns = null;
  grid.tempColumnOrder = null;

  // Chave para localStorage (permite múltiplas tabelas na mesma página)
  grid.storageKey = grid.options.storageKey || `skargrid-config-${grid.container.id || 'default'}`;

  /**
   * Salva configuração de colunas no localStorage
   */
  grid.saveColumnConfig = function() {
    if (!grid.options.persistColumnConfig) return;
    
    try {
      const config = {
        visibleColumns: Array.from(this.visibleColumns),
        columnOrder: this.columnOrder,
        timestamp: Date.now()
      };
      localStorage.setItem(this.storageKey, JSON.stringify(config));
    } catch (e) {
      console.warn('Não foi possível salvar configuração de colunas:', e);
    }
  };

  /**
   * Carrega configuração de colunas do localStorage
   */
  grid.loadColumnConfig = function() {
    if (!grid.options.persistColumnConfig) return false;
    
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) return false;

      const config = JSON.parse(saved);
      
      // Valida se todas as colunas ainda existem
      const currentFields = this.options.columns.map(col => col.field);
      const validVisible = config.visibleColumns.filter(field => currentFields.includes(field));
      const validOrder = config.columnOrder.filter(field => currentFields.includes(field));
      
      // Adiciona novas colunas que não estavam na config salva
      currentFields.forEach(field => {
        if (!validOrder.includes(field)) {
          validOrder.push(field);
        }
      });

      this.visibleColumns = new Set(validVisible);
      this.columnOrder = validOrder;
      
      return true;
    } catch (e) {
      console.warn('Não foi possível carregar configuração de colunas:', e);
      return false;
    }
  };

  /**
   * Limpa configuração salva
   */
  grid.clearSavedColumnConfig = function() {
    try {
      localStorage.removeItem(this.storageKey);
    } catch (e) {
      console.warn('Não foi possível limpar configuração:', e);
    }
  };

  // Carrega configuração salva (se existir)
  grid.loadColumnConfig();

  /**
   * Renderiza botão de configuração de colunas
   */
  grid.renderColumnConfigButton = function() {
    const btn = document.createElement('button');
    btn.className = 'skargrid-clear-filters-btn';
    btn.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
        <circle cx="12" cy="12" r="3"/>
      </svg>
    `;
    btn.title = 'Configurar Colunas';

    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      this.toggleColumnConfigModal();
    });

    return btn;
  };

  /**
   * Abre/fecha modal de configuração de colunas
   */
  grid.toggleColumnConfigModal = function() {
    let modal = this.container.querySelector('.skargrid-column-config-modal');
    
    if (modal) {
      modal.remove();
      return;
    }

    // Guarda estado atual para permitir cancelamento
    this.tempVisibleColumns = new Set(this.visibleColumns);
    this.tempColumnOrder = [...this.columnOrder];

    modal = this.renderColumnConfigModal();
    const wrapper = this.container.querySelector('.skargrid-wrapper');
    wrapper.appendChild(modal);

    // Previne propagação de cliques dentro do modal
    modal.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Fecha ao clicar fora
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!modal.contains(e.target)) {
          // Cancela mudanças ao fechar sem aplicar
          this.tempVisibleColumns = null;
          this.tempColumnOrder = null;
          modal.remove();
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 10);
  };

  /**
   * Renderiza modal de configuração de colunas
   */
  grid.renderColumnConfigModal = function() {
    const modal = document.createElement('div');
    modal.className = 'skargrid-column-config-modal';

    const header = document.createElement('div');
    header.className = 'skargrid-config-header';
    header.innerHTML = `
      <h3>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 6px;">
          <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
          <circle cx="12" cy="12" r="3"/>
        </svg>
        Configurar Colunas
      </h3>
      <p>Marque para exibir, arraste ou use as setas para reordenar</p>
    `;

    // Botões de ação NO TOPO (dentro do header)
    const headerActions = document.createElement('div');
    headerActions.className = 'skargrid-config-header-actions';

    const btnRestore = document.createElement('button');
    btnRestore.className = 'skargrid-config-action-btn';
    btnRestore.innerHTML = '↺ Restaurar';
    btnRestore.title = 'Restaurar configuração padrão';
    btnRestore.addEventListener('click', () => this.restoreDefaultColumns());

    const btnCancel = document.createElement('button');
    btnCancel.className = 'skargrid-config-action-btn';
    btnCancel.textContent = 'Cancelar';
    btnCancel.addEventListener('click', () => {
      this.tempVisibleColumns = null;
      this.tempColumnOrder = null;
      modal.remove();
    });

    const btnApply = document.createElement('button');
    btnApply.className = 'skargrid-config-action-btn skargrid-config-action-btn-primary';
    btnApply.textContent = '✓ Aplicar';
    btnApply.addEventListener('click', () => this.applyColumnConfig());

    headerActions.appendChild(btnRestore);
    headerActions.appendChild(btnCancel);
    headerActions.appendChild(btnApply);
    header.appendChild(headerActions);

    const list = document.createElement('div');
    list.className = 'skargrid-config-list';

    // Renderiza cada coluna na ordem temporária
    this.tempColumnOrder.forEach((field, index) => {
      const column = this.options.columns.find(col => col.field === field);
      if (!column) return;

      const item = document.createElement('div');
      item.className = 'skargrid-config-item';
      item.dataset.field = field;
      item.draggable = true;

      // Drag and drop eventos
      item.addEventListener('dragstart', (e) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', field);
        item.classList.add('dragging');
      });

      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        
        // Atualiza estado dos botões ↑↓ após o drag
        setTimeout(() => {
          const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
          items.forEach((item, idx) => {
            const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
            const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
            if (btnUp) btnUp.disabled = idx === 0;
            if (btnDown) btnDown.disabled = idx === items.length - 1;
          });
        }, 50);
      });

      item.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        
        const draggingItem = list.querySelector('.dragging');
        if (draggingItem && draggingItem !== item) {
          const rect = item.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          
          if (e.clientY < midY) {
            list.insertBefore(draggingItem, item);
          } else {
            list.insertBefore(draggingItem, item.nextSibling);
          }
        }
      });

      item.addEventListener('drop', (e) => {
        e.preventDefault();
        // Atualiza a ordem baseada na posição dos elementos no DOM
        const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
        this.tempColumnOrder = items.map(el => el.dataset.field);
        
        // Atualiza estado dos botões ↑↓
        items.forEach((item, idx) => {
          const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
          const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
          if (btnUp) btnUp.disabled = idx === 0;
          if (btnDown) btnDown.disabled = idx === items.length - 1;
        });
      });

      // Checkbox para visibilidade (usa estado temporário)
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = this.tempVisibleColumns.has(field);
      checkbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          this.tempVisibleColumns.add(field);
        } else {
          this.tempVisibleColumns.delete(field);
        }
      });

      const label = document.createElement('label');
      label.textContent = column.title || field;
      label.addEventListener('click', () => {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      });

      // Ícone de arrastar
      const dragHandle = document.createElement('span');
      dragHandle.className = 'skargrid-drag-handle';
      dragHandle.innerHTML = '⋮⋮';
      dragHandle.title = 'Arrastar para reordenar';

      // Botões de ordenação (mantidos como alternativa)
      const btnUp = document.createElement('button');
      btnUp.className = 'skargrid-config-move-btn';
      btnUp.innerHTML = '↑';
      btnUp.disabled = index === 0;
      btnUp.addEventListener('click', () => this.moveColumnTemp(field, 'up'));

      const btnDown = document.createElement('button');
      btnDown.className = 'skargrid-config-move-btn';
      btnDown.innerHTML = '↓';
      btnDown.disabled = index === this.tempColumnOrder.length - 1;
      btnDown.addEventListener('click', () => this.moveColumnTemp(field, 'down'));

      item.appendChild(dragHandle);
      item.appendChild(checkbox);
      item.appendChild(label);
      item.appendChild(btnUp);
      item.appendChild(btnDown);
      list.appendChild(item);
    });

    modal.appendChild(header);
    modal.appendChild(list);

    return modal;
  };

  /**
   * Move uma coluna no estado temporário
   */
  grid.moveColumnTemp = function(field, direction) {
    const currentIndex = this.tempColumnOrder.indexOf(field);
    if (currentIndex === -1) return;

    const newOrder = [...this.tempColumnOrder];
    
    if (direction === 'up' && currentIndex > 0) {
      [newOrder[currentIndex], newOrder[currentIndex - 1]] = 
      [newOrder[currentIndex - 1], newOrder[currentIndex]];
    } else if (direction === 'down' && currentIndex < newOrder.length - 1) {
      [newOrder[currentIndex], newOrder[currentIndex + 1]] = 
      [newOrder[currentIndex + 1], newOrder[currentIndex]];
    }

    this.tempColumnOrder = newOrder;
    
    // Atualiza apenas a lista dentro do modal (não recria tudo)
    const modal = this.container.querySelector('.skargrid-column-config-modal');
    if (modal) {
      const list = modal.querySelector('.skargrid-config-list');
      if (list) {
        // Re-renderiza a lista
        list.innerHTML = '';
        this.tempColumnOrder.forEach((field, index) => {
          const column = this.options.columns.find(col => col.field === field);
          if (!column) return;

          const item = document.createElement('div');
          item.className = 'skargrid-config-item';
          item.dataset.field = field;
          item.draggable = true;

          // Drag and drop eventos
          item.addEventListener('dragstart', (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', field);
            item.classList.add('dragging');
          });

          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            
            // Atualiza estado dos botões ↑↓ após o drag
            setTimeout(() => {
              const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
              items.forEach((item, idx) => {
                const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
                const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
                if (btnUp) btnUp.disabled = idx === 0;
                if (btnDown) btnDown.disabled = idx === items.length - 1;
              });
            }, 50);
          });

          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const draggingItem = list.querySelector('.dragging');
            if (draggingItem && draggingItem !== item) {
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;
              
              if (e.clientY < midY) {
                list.insertBefore(draggingItem, item);
              } else {
                list.insertBefore(draggingItem, item.nextSibling);
              }
            }
          });

          item.addEventListener('drop', (e) => {
            e.preventDefault();
            const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
            this.tempColumnOrder = items.map(el => el.dataset.field);
            
            // Atualiza estado dos botões ↑↓
            items.forEach((item, idx) => {
              const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
              const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
              if (btnUp) btnUp.disabled = idx === 0;
              if (btnDown) btnDown.disabled = idx === items.length - 1;
            });
          });

          // Checkbox para visibilidade
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = this.tempVisibleColumns.has(field);
          checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              this.tempVisibleColumns.add(field);
            } else {
              this.tempVisibleColumns.delete(field);
            }
          });

          const label = document.createElement('label');
          label.textContent = column.title || field;
          label.addEventListener('click', () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          });

          // Ícone de arrastar
          const dragHandle = document.createElement('span');
          dragHandle.className = 'skargrid-drag-handle';
          dragHandle.innerHTML = '⋮⋮';
          dragHandle.title = 'Arrastar para reordenar';

          // Botões de ordenação
          const btnUp = document.createElement('button');
          btnUp.className = 'skargrid-config-move-btn';
          btnUp.innerHTML = '↑';
          btnUp.disabled = index === 0;
          btnUp.addEventListener('click', () => this.moveColumnTemp(field, 'up'));

          const btnDown = document.createElement('button');
          btnDown.className = 'skargrid-config-move-btn';
          btnDown.innerHTML = '↓';
          btnDown.disabled = index === this.tempColumnOrder.length - 1;
          btnDown.addEventListener('click', () => this.moveColumnTemp(field, 'down'));

          item.appendChild(dragHandle);
          item.appendChild(checkbox);
          item.appendChild(label);
          item.appendChild(btnUp);
          item.appendChild(btnDown);
          list.appendChild(item);
        });
      }
    }
  };

  /**
   * Aplica as configurações de colunas
   */
  grid.applyColumnConfig = function() {
    if (this.tempVisibleColumns) {
      this.visibleColumns = new Set(this.tempVisibleColumns);
    }
    if (this.tempColumnOrder) {
      this.columnOrder = [...this.tempColumnOrder];
    }

    this.tempVisibleColumns = null;
    this.tempColumnOrder = null;

    const modal = this.container.querySelector('.skargrid-column-config-modal');
    if (modal) modal.remove();

    // Salva configuração no localStorage
    this.saveColumnConfig();

    this.render();
  };

  /**
   * Restaura configuração padrão de colunas (apenas no modal)
   */
  grid.restoreDefaultColumns = function() {
    // Restaura para configuração original de fábrica (apenas temp)
    this.tempVisibleColumns = new Set(this.options.columns.map(col => col.field));
    this.tempColumnOrder = this.options.columns.map(col => col.field);

    // Atualiza a lista no modal
    const modal = this.container.querySelector('.skargrid-column-config-modal');
    if (modal) {
      const list = modal.querySelector('.skargrid-config-list');
      if (list) {
        list.innerHTML = '';
        this.tempColumnOrder.forEach((field, index) => {
          const column = this.options.columns.find(col => col.field === field);
          if (!column) return;

          const item = document.createElement('div');
          item.className = 'skargrid-config-item';
          item.dataset.field = field;
          item.draggable = true;

          // Drag and drop eventos
          item.addEventListener('dragstart', (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', field);
            item.classList.add('dragging');
          });

          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            
            // Atualiza estado dos botões ↑↓ após o drag
            setTimeout(() => {
              const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
              items.forEach((item, idx) => {
                const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
                const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
                if (btnUp) btnUp.disabled = idx === 0;
                if (btnDown) btnDown.disabled = idx === items.length - 1;
              });
            }, 50);
          });

          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const draggingItem = list.querySelector('.dragging');
            if (draggingItem && draggingItem !== item) {
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;
              
              if (e.clientY < midY) {
                list.insertBefore(draggingItem, item);
              } else {
                list.insertBefore(draggingItem, item.nextSibling);
              }
            }
          });

          item.addEventListener('drop', (e) => {
            e.preventDefault();
            const items = Array.from(list.querySelectorAll('.skargrid-config-item'));
            this.tempColumnOrder = items.map(el => el.dataset.field);
            
            // Atualiza estado dos botões ↑↓
            items.forEach((item, idx) => {
              const btnUp = item.querySelector('.skargrid-config-move-btn:first-of-type');
              const btnDown = item.querySelector('.skargrid-config-move-btn:last-of-type');
              if (btnUp) btnUp.disabled = idx === 0;
              if (btnDown) btnDown.disabled = idx === items.length - 1;
            });
          });

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = this.tempVisibleColumns.has(field);
          checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              this.tempVisibleColumns.add(field);
            } else {
              this.tempVisibleColumns.delete(field);
            }
          });

          const label = document.createElement('label');
          label.textContent = column.title || field;
          label.addEventListener('click', () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          });

          // Ícone de arrastar
          const dragHandle = document.createElement('span');
          dragHandle.className = 'skargrid-drag-handle';
          dragHandle.innerHTML = '⋮⋮';
          dragHandle.title = 'Arrastar para reordenar';

          const btnUp = document.createElement('button');
          btnUp.className = 'skargrid-config-move-btn';
          btnUp.innerHTML = '↑';
          btnUp.disabled = index === 0;
          btnUp.addEventListener('click', () => this.moveColumnTemp(field, 'up'));

          const btnDown = document.createElement('button');
          btnDown.className = 'skargrid-config-move-btn';
          btnDown.innerHTML = '↓';
          btnDown.disabled = index === this.tempColumnOrder.length - 1;
          btnDown.addEventListener('click', () => this.moveColumnTemp(field, 'down'));

          item.appendChild(dragHandle);
          item.appendChild(checkbox);
          item.appendChild(label);
          item.appendChild(btnUp);
          item.appendChild(btnDown);
          list.appendChild(item);
        });
      }
    }
  };

  /**
   * Define a visibilidade de uma coluna
   */
  grid.setColumnVisibility = function(field, visible) {
    if (visible) {
      this.visibleColumns.add(field);
    } else {
      this.visibleColumns.delete(field);
    }
    this.render();
  };

  /**
   * Reordena as colunas
   */
  grid.reorderColumns = function(newOrder) {
    // Valida se todos os fields existem
    const validFields = this.options.columns.map(col => col.field);
    const isValid = newOrder.every(field => validFields.includes(field));
    
    if (!isValid) {
      console.warn('Ordem inválida: alguns fields não existem');
      return;
    }

    this.columnOrder = newOrder;
    this.render();
  };

  /**
   * Obtém as colunas ordenadas e visíveis
   */
  grid.getOrderedVisibleColumns = function() {
    return this.columnOrder
      .filter(field => this.visibleColumns.has(field))
      .map(field => this.options.columns.find(col => col.field === field))
      .filter(col => col !== undefined);
  };
}

/**
 * Skargrid - Export Module
 * Módulo de exportação de dados (CSV)
 */

(function() {
  'use strict';

  /**
   * Renderiza botão "Exportar CSV"
   */
  Skargrid.prototype.renderExportCSVButton = function() {
    const exportButton = document.createElement('button');
    exportButton.className = 'skargrid-clear-filters-btn';
    exportButton.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
    `;
    exportButton.title = 'Exportar CSV';
    exportButton.onclick = () => this.exportToCSV();
    
    return exportButton;
  };

  /**
   * Exporta dados visíveis para CSV
   */
  Skargrid.prototype.exportToCSV = function(filename) {
    filename = filename || 'skargrid-export.csv';

    // Obtém colunas visíveis na ordem atual
    const visibleColumns = this.columnOrder
      .filter(field => this.visibleColumns.has(field))
      .map(field => this.options.columns.find(col => col.field === field))
      .filter(col => col); // Remove undefined

    // Se não houver colunas visíveis, usa todas
    if (visibleColumns.length === 0) {
      visibleColumns.push(...this.options.columns);
    }

    // Cabeçalho CSV
    const headers = visibleColumns.map(col => this.escapeCSV(col.title));
    const csvRows = [headers.join(',')];

    // Dados (usa dados filtrados/pesquisados se houver)
    const dataToExport = this.filteredData.length > 0 ? this.filteredData : this.data;

    // Adiciona linhas de dados
    dataToExport.forEach(row => {
      const values = visibleColumns.map(col => {
        let value = row[col.field];
        
        // Se a coluna tem render customizado, extrai o texto puro
        if (col.render && typeof col.render === 'function') {
          // Renderiza e remove HTML tags
          const rendered = col.render(value, row);
          value = this.stripHTML(rendered);
        }
        
        // Formata valores
        if (value === null || value === undefined) {
          value = '';
        } else if (typeof value === 'boolean') {
          value = value ? 'Sim' : 'Não';
        } else if (typeof value === 'number') {
          value = value.toString();
        } else {
          value = value.toString();
        }
        
        return this.escapeCSV(value);
      });
      
      csvRows.push(values.join(','));
    });

    // Cria CSV completo
    const csvContent = csvRows.join('\n');

    // Adiciona BOM para UTF-8 (suporte a acentos no Excel)
    const BOM = '\uFEFF';
    const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });

    // Download do arquivo
    if (navigator.msSaveBlob) {
      // IE 10+
      navigator.msSaveBlob(blob, filename);
    } else {
      const link = document.createElement('a');
      if (link.download !== undefined) {
        // Navegadores modernos
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    }
  };

  /**
   * Escapa valores para CSV (adiciona aspas e escapa aspas internas)
   */
  Skargrid.prototype.escapeCSV = function(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    
    // Se contém vírgula, quebra de linha ou aspas, envolve em aspas
    if (value.includes(',') || value.includes('\n') || value.includes('"')) {
      // Escapa aspas duplicando-as
      value = value.replace(/"/g, '""');
      return `"${value}"`;
    }
    
    return value;
  };

  /**
   * Remove tags HTML de uma string
   */
  Skargrid.prototype.stripHTML = function(html) {
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || '';
  };

  /**
   * Exporta dados selecionados para CSV
   */
  Skargrid.prototype.exportSelectedToCSV = function(filename) {
    filename = filename || 'skargrid-selected.csv';
    
    const selectedRows = this.getSelectedRows();
    if (selectedRows.length === 0) {
      alert('Nenhuma linha selecionada para exportar.');
      return;
    }

    // Temporariamente substitui filteredData com selecionados
    const originalFiltered = this.filteredData;
    this.filteredData = selectedRows;
    
    // Exporta
    this.exportToCSV(filename);
    
    // Restaura
    this.filteredData = originalFiltered;
  };

})();


return Skargrid;
}));